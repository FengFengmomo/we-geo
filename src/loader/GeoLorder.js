import { ShapeGeometry, Mesh, ExtrudeGeometry, 
    BufferGeometry, Line, LineBasicMaterial, 
    PointsMaterial, MeshPhongMaterial, 
    Points, Group, Vector2, 
    Shape, DoubleSide, MeshLambertMaterial,
    CatmullRomCurve3} from 'three'
import { UnitsUtils } from '../utils/UnitsUtils';
import { Vector3 } from 'three';
import Shapes from './Shapes';
import { Colors } from '../utils/Colors'


/**
 * 本类用于加载geojson文件，主要为了加载行政区划边界
 * 参考链接：https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_shapes.html
 * 参考链接：https://threejs.org/examples/#webgl_geometry_shapes
 * 参考链接：https://threejs.org/docs/index.html?q=shap#api/en/extras/core/Shape
 */
export class GeoLorder{
    static Flat = 100;
    static Extruded = 200;
    static LineReal = 300;
    static LineSampled = 400;
    static PointLineReal = 500;
    static PointLineSampled = 600;
    static ShapePath = 700;

    /**
     * 带贴图的形状
     * @param {*} shape 形状
     * @param {*} texture 贴图
     * @param {*} position 位置
     * @param {*} rotation 旋转
     * @param {*} scale 缩放
     */
    addShapeWithTexture( shape, texture, position, rotation, scale) {

        // flat shape with texture
        // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

        let geometry = new ShapeGeometry( shape );

        let mesh = new Mesh( geometry, new MeshPhongMaterial( { side: DoubleSide, map: texture } ) );
        if ( position ) {
            mesh.position.copy( position );
        }
        if ( rotation ) {
            mesh.rotation.copy( rotation );
        }
        if ( scale ) {
            mesh.scale.copy( scale );
        }
        return mesh;
    }
    /**
     * 平面形状
     * @param {*} shape 形状
     * @param {*} color 颜色
     * @param {*} position 位置
     * @param {*} rotation 旋转
     * @param {*} scale 缩放
     */
    addShapeFlat( shape, color = 0xffffff, position, rotation, scale) {
        // flat shape

        let geometry = new ShapeGeometry( shape );

        let mesh = new Mesh( geometry, new MeshPhongMaterial( { color: color, side: DoubleSide } ) );
        if ( position ) {
            mesh.position.copy( position );
        }
        if ( rotation ) {
            mesh.rotation.copy( rotation );
        }
        if ( scale ) {
            mesh.scale.copy( scale );
        }
        return mesh;

    }

    /**
     * 带厚度的形状
     * @param {*} shape 
     * @param {*} extrudeSettings 参考值 const extrudeSettings = { depth: 8, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
     * @param {*} color 颜色
     * @param {*} position 位置
     * @param {*} rotation 旋转
     * @param {*} scale 缩放
     */
    addShapeExtruded( shape, extrudeSettings, color = 0xffffff, position, rotation, scale){
        
        // extruded shape

        let geometry = new ExtrudeGeometry( shape, extrudeSettings );

        let mesh = new Mesh( geometry, new MeshPhongMaterial( { color: color } ) );
        if ( position ) {
            mesh.position.copy( position );
        }
        if ( rotation ) {
            mesh.rotation.copy( rotation );
        }
        if ( scale ) {
            mesh.scale.copy( scale );
        }
        return mesh;
    }

    // 以真实点画线
    addSolidLineReal( shape, color = 0xffffff, position, rotation, scale ) {
        shape.autoClose = true;
        const points = shape.getPoints();
        const geometryPoints = new BufferGeometry().setFromPoints( points );
        let line = new Line( geometryPoints, new LineBasicMaterial( { color: color } ) );
        if ( position ) {
            line.position.copy( position );
        }
        if ( rotation ) {
            line.rotation.copy( rotation );
        }
        if ( scale ) {
            line.scale.copy( scale );
        }
        return line;
    }
    // 根据采样点划线
    addSolidLineSampled( shape, color = 0xffffff, position, rotation, scale ) {
        shape.autoClose = true;
        const spacedPoints = shape.getSpacedPoints( 50 );
        const geometrySpacedPoints = new BufferGeometry().setFromPoints( spacedPoints );
        let line = new Line( geometrySpacedPoints, new MeshPhongMaterial( { color: color } ) );
        if ( position ) {
            line.position.copy( position );
        }
        if ( rotation ) {
            line.rotation.copy( rotation );
        }
        if ( scale ) {
            line.scale.copy( scale );
        }
        return line;
    }

    addPointLineReal( shape, color = 0xffffff, position, rotation, scale ) {
        shape.autoClose = true;

        const points = shape.getPoints();
        const geometryPoints = new BufferGeometry().setFromPoints( points );
        let particles = new Points( geometryPoints, new PointsMaterial( { color: color, size: 400 } ) );
        if ( position ) {
            particles.position.copy( position );
        }
        if ( rotation ) {
            particles.rotation.copy( rotation );
        }
        if ( scale ) {
            particles.scale.copy( scale );
        }
        return particles;
    }

    addPointLineSampled( shape, color = 0xffffff, position, rotation, scale ) {
        shape.autoClose = true;

        const spacedPoints = shape.getSpacedPoints( 50 );
        const geometrySpacedPoints = new BufferGeometry().setFromPoints( spacedPoints );
        particles = new Points( geometrySpacedPoints, new PointsMaterial( { color: color, size: 400 } ) );
        if ( position ) {
            particles.position.copy( position );
        }
        if ( rotation ) {
            particles.rotation.copy( rotation );
        }
        if ( scale ) {
            particles.scale.copy( scale );
        }
        return particles;
    }

    /**
     * 
     * @param {*} shape 形状
     * @param {*} ponits 路径的点 ，Object3d类型
     * @param {*} color 颜色
     * @returns 
     * 参考：https://threejs.org/docs/index.html?q=CatmullRomCurve3#api/en/extras/curves/CatmullRomCurve3
     *      https://threejs.org/examples/#webgl_geometry_extrude_shapes
     * 
     * 也可以制作管道几何体：
     *      https://www.cnblogs.com/vadim-web/p/13282658.html  该网页最后
     */
    addShapePath( shape, ponits, color = 0xffffff) {
        const spline = new CatmullRomCurve3( ponits );
        spline.curveType = 'catmullrom';
        spline.closed = true;
        const extrudeSettings = {
            steps: 100,
            bevelEnabled: false,
            extrudePath: spline
        };
        const geometry = new ExtrudeGeometry( shape, extrudeSettings );

        const material = new MeshPhongMaterial( { color: color, wireframe: false } );

        const mesh = new Mesh( geometry, material );
        return mesh;
    }
    
    // 加载行政区划json
    // 也可以适配加载常规的geojson, 后续再进行调试
    async loadRegionJson(path, color, mode = GeoLorder.LineReal, options = {}, position, rorate, scale){
        let group = new Group();
        await fetch(path).then(res=>res.json()).then(data=>{
            let features = data.features;
            features.forEach(feature=>{
                let properties = feature.properties;
                let geometry = feature.geometry;
                let type = feature.type;
                let coordinates = geometry.coordinates;
                let typeGeometry = geometry.type;
                if (typeGeometry === "MultiPolygon") { // 目前暂时仅仅支持行政区划方向的数据进行解析
                    for(let multiPolygon of coordinates){
                        const shapePonit = [];
                        let polygon = multiPolygon[0]; // 每次取第一个图形，geojson里面是这样设置的
                        for(let point of polygon){
                            // Todo 经纬度转笛卡尔坐标系
                            let coord = UnitsUtils.datumsToSpherical(point[1], point[0]); // 经纬度转笛卡尔坐标系, point 中的经纬度是反的【lon,lat】
                            shapePonit.push(new Vector2(coord.x, -coord.y));
                        }
                        let center = properties.center; // 转成笛卡尔坐标系,行政中心
                        let centroid = properties.centroid; // 转成笛卡尔坐标系，形心
                        let centerCoord = UnitsUtils.datumsToSpherical(centroid[1], centroid[0]);
                        // position = new Vector3(centerCoord.x, -centerCoord.y, 0 );
                        let shape = new Shape(shapePonit);
                        let mesh = this.produce(mode, shape, color, position, rorate, scale);
                        mesh.name = properties.name;
                        mesh.transparent = true;
                        mesh.opacity = 0.6;
                        group.add(mesh);
                        mesh = this.produce(GeoLorder.ShapePath, shape, Colors.Blue);
                        mesh.name = properties.name;
                        group.add(mesh);
                    }
                }
            });
        });
        group.rotation.set( Math.PI/2,0,0);
        return group;
    }
    // 生成具体的mesh
    produce(mode, shape, color, position, rorate, scale){
        let mesh = null;
        switch (mode) {
            case GeoLorder.Flat:
                mesh = this.addShapeFlat(shape, color, position, rorate, scale);
                break;
            case GeoLorder.Extruded:
                mesh = this.addShapeExtruded(shape, color, position, rorate, scale);
                break;
            case GeoLorder.LineReal:
                mesh = this.addSolidLineReal(shape, color, position, rorate, scale);
                break;
            case GeoLorder.LineSampled:
                mesh = this.addSolidLineSampled(shape, color, position, rorate, scale);
                break;
            case GeoLorder.PointLineReal:
                mesh = this.addPointLineReal(shape, color, position, rorate, scale);
                break;
            case GeoLorder.PointLineSampled:
                mesh = this.addPointLineSampled(shape, color, position, rorate, scale);
                break;
            case GeoLorder.ShapePath:
                let shapes = new Shapes();
                shape.getPoints();
                let points = [];
                for(let point of shape.getPoints()){
                    points.push(new Vector3(point.x, point.y, 0));
                }
                mesh = this.addShapePath(shapes.getCircle(), points, color, position, rorate, scale);
                break;
            default:
                mesh  = null;
        }
        return mesh;
    }

    // 矩阵类型的数组，每个维度的深度都是一样
    /**
     * 判断数组深度
     * @param {*} arr 数组 
     * @param {*} matrix 是否是规整的数组
     * @returns 
     */   
    arrDepth(arr, matrix){
        if (!Array.isArray(arr)) {   // 判断是否为数组
            return 0;
          }
          let depth = 1;               // 初始化深度为 1
          if (matrix) {
            const cur = arr[0];
            if (Array.isArray(cur)) {  // 如果当前元素仍为数组，递归遍历
                const curDepth = this.arrDepth(cur, matrix) + 1;
                depth = Math.max(depth, curDepth);
            }
          } else{
            for (let i = 0; i < arr.length; i++) {
                const cur = arr[i];
                if (Array.isArray(cur)) {  // 如果当前元素仍为数组，递归遍历
                  const curDepth = this.arrDepth(cur, matrix) + 1;
                  depth = Math.max(depth, curDepth);
                }
              }
          }
          
          return depth;
    }
}
    